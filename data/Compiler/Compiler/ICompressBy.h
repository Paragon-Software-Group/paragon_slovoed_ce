#pragma once
#include "Out.h"

/// Данный класс описывает интерфейс для сжатия данных.
/** Любые данные словаря (списки слов, переводы) проходят через реализацию этого класса.
	## Общие принципы сжатия
	### Основные этапы
	Так как все алгоритмы сжатия реализуют интерфейс данного класса, то рассмотрим здесь
	общую последовательность действий при сжатии. В общем случае работа алгоритма сжатия
	состоит из четырех этапов: инициализации, наполнения модели (опционально), собственно
	сжатия с последующим выводом сжатого текста в принимающий объект и завершения работы. 

	#### 1. Инициализация
	Класс сжатия инициализируется методом @ref Init,
	который в качестве параметра принимает указатель на объект типа @ref COut,
	предназначенный для вывода в него уже сжатого текста.
	#### 2. Наполнение модели
	Опциональная стадия сжатия. Наполнение происходит в режиме @ref eInitialization 
	c помощью метода @ref AddText. Режим сжатия изменяется методом @ref SetMode.
	#### 3. Сжатие и вывод сжатого текста
	Сжатие происходит в режиме @ref eCompress c помощью метода @ref AddText.
	Переданный текст сжимается и выводится в соответствующий объект @ref COut.\n
	Метод @ref AddData позволяет добавить данные без сжатия (такие как изображения или
	звуки).
	#### 4. Завершение работы
	Метод @ref Close завершает работу класса сжатия, в частности удаляет данные деревьев.

	### Извлечение информация для декодирования
	Для того, чтобы декодировать текст или данные определенного типа нужно получить 
	соответстующее этому типу дерево сжатия. Сделать это можно с помощью метода.
	@ref GetCompressedTreeCount. В результате будет получен массив данных дерева сжатия.\n\n
	Структура данных зависит от метода сжатия, но в целом она такова:
	- Заголовок с описанием размера данных, количества бит для сжатия и т.д.
	- Собственно данные (строчки или одиночные символы)

*/
class ICompressBy
{
public:

	/// Здесь перечислены режимы работы класса сжатия
	enum EMode{
		/// Инициализация - данные передаются для предварительного анализа.
		eInitialization = 0,
		/// Данные передаются для сжатия и сохранения.
		eCompress
	};

	/// Деструктор
	virtual ~ICompressBy(void){};

	/** ********************************************************************
	*  Производит инициализацию конкретную реализацию способа сжатия
	*
	* @param aOut - ссылка на класс который примет сжатые данные.
	************************************************************************/
	virtual void Init(COut &aOut) = 0;

	/** ********************************************************************
	*  Производит инициализацию конкретную реализацию способа сжатия
	*
	* @param aMode - режим в котором будет работать сжатие
	*
	* @return код ошибки
	************************************************************************/
	virtual int SetMode(ICompressBy::EMode aMode) = 0;

	/** ********************************************************************
	*  Добавляет данные перед сжатием.
	*
	* @param aData - число которое необходимо сохранить.
	* @param aDataSize - количество бит которые необходимо сохранить(считаются только младшие биты).
	*
	* @return код ошибки
	************************************************************************/
	virtual int AddData(UInt64 aData, UInt32 aDataSize) = 0;

	/** ********************************************************************
	*  Добавляет данные перед сжатием.
	*
	* @param aDataPtr - указатель на буфер с данными
	* @param aDataSize - количество элементов данных в буфере, которые необходимо 
	*					сохранить.
	* @param aDataType - тип данных которые сохраняются.
	*
	* @return код ошибки
	************************************************************************/
	virtual int AddText(const UInt16 *aDataPtr, UInt32 aDataSize, UInt32 aDataType) = 0;
	
	/***********************************************************************
	* Добавляет пустые деревья, если их реальное число меньше чем aTotalCount
	* Это нужно, чтобы количество деревьев соответствовало количеству стилей,
	* чего не происходит, если некоторые стили в словаре не содержат данных
	*
	* @param aTotalCount	- общее количество деревьев, которое должно быть
	*
	* @return код ошибки
	************************************************************************/
	virtual int AddEmptyTrees(UInt32 aTotalCount) = 0;

	/** ********************************************************************
	*  Возвращает количество сохраненных бит информации. А именно позицию с 
	*  которой можно будет продолжить декодирование(при работе декомпрессора).
	*
	* @return Количество сохраненных бит.
	************************************************************************/
	virtual UInt32 GetCurrentPos() const = 0;

	/** ********************************************************************
	* Возвращает количество деревьев используемых при сжатии
	*
	* @return количество деревьев
	************************************************************************/
	virtual UInt32 GetCompressedTreeCount() const = 0;

	/** ********************************************************************
	* Возвращает данные указанного дерева. 
	*
	* @param aIndex - номер дерева для которого нужно получить данные
	* @param aDataPtr - по этому указателю будет записан указатель на данные дерева
	* @param aDataSize - по этому указателю будет записан размер данных дерева
	*
	* @return код ошибки
	************************************************************************/
	virtual int GetCompressedTree(UInt32 aIndex, const UInt8 **aDataPtr, UInt32 *aDataSize) = 0;
};

/// Класс реализует функционал общий для всех компрессоров присутствующих в компиляторе
class CBaseCompressor : public ICompressBy
{
public:
	CBaseCompressor() : m_Mode(eInitialization), m_Out(nullptr) {}

	/// Производит инициализацию конкретной реализацию способа сжатия
	void Init(COut &aOut) override
	{
		m_Out = &aOut;
	}

	/// Устанавливает режим сжатия
	int SetMode(EMode aMode) override
	{
		if (aMode == m_Mode)
			return ERROR_NO;

		// disallow switching from eCompress back to eInitialization
		assert(aMode != eInitialization);

		m_Mode = aMode;
		return BuildTrees();
	}

	/// Добавляет данные перед сжатием
	int AddData(UInt64 aData, UInt32 aDataSize) override
	{
		return m_Mode == eInitialization ? ERROR_NO : m_Out->AddBits(aData, aDataSize);
	}

	/// Возвращает количество сохраненных бит информации
	UInt32 GetCurrentPos() const override
	{
		return m_Mode == eInitialization ? 0 : m_Out->GetCurrentPos();
	}

	/// Возвращает данные указанного дерева.
	int GetCompressedTree(UInt32 aIndex, const UInt8 **aDataPtr, UInt32 *aDataSize) override
	{
		if (aIndex >= GetCompressedTreeCount())
			return ERROR_WRONG_INDEX;
		const MemoryRef mem = GetCompressedTree(aIndex);
		*aDataPtr = mem.data();
		*aDataSize = static_cast<UInt32>(mem.size());
		return ERROR_NO;
	}

protected:

	/// Производит постройку деревьев для последующего сжатия
	virtual int BuildTrees() = 0;

	/// Возвращает данные указанного дерева.
	virtual MemoryRef GetCompressedTree(UInt32 aIndex) = 0;

	/// Режим работы - подготовка или собственно сжатие.
	EMode m_Mode;

	/// Указатель на класс занимающийся сохранением готовой информации.
	COut *m_Out;
};
