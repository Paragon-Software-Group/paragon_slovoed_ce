/**
****************************************************************
*
*   @file WordSet.h
*
*   (c) Paragon Software (SHDD) 2004
*
*	Файл описывает интерфейс класса WordSet, который хранит 
*   и обрабатывает список слов вместе с ссылками на соотвующие
*   им правила.
*
*   \author Карпизин Вячеслав
*
*	Файл создан: 8.09.2004
*	
************************************************************* */


#ifndef __MORPHO_WORD_SET_V1_
#define __MORPHO_WORD_SET_V1_


#ifdef _ML_PARSER_
	#include <map>
	#include <string>
	#include <vector>
	#include "../huffman.h"
#else 
//	#define 	 DIGITS_FOR_RULE_POS		4
#endif


#define DEFAULT_BLOCK_SIZE		0x8000L

#define MAX_WORDS_BLOCKS_NUMBER ((32*0x10000/DEFAULT_BLOCK_SIZE)*8)

	typedef UInt8 BlockType[DEFAULT_BLOCK_SIZE];

	typedef BlockType*		pBlockType; 


/*
// _ML_PARSER_ - установлена, когда класс заполняется и сохраняется в файл
*/

//////////////////////////////////////////////////////////////////////////////////////////////
//
//	Класс WordSet. Хранит списки слов-исключений и списки правил, в соответствии с которыми эти слова изменяются. 
//
//////////////////////////////////////////////////////////////////////////////////////////////


class WordSet_v1
{
public:
#ifdef _ML_PARSER_
	WordSet_v1()
	{
		this->ArchiveBlockArray = NULL;
		this->ArchiveBlockCounter = 0;
		this->RuleSetArray = NULL;
		this->RuleSetArraySize = 0;
		this->IndexArray = NULL;
		this->IndexTableSize = 0;
		this->HaffmanTable = NULL;
		this->HaffmanTableSize = 0;
		this->w.clear();
	};

	~WordSet_v1()
	{
		if (HaffmanTable)
			sldMemFree((void *)HaffmanTable);
	};
	
#endif

	////////////////////////////////////////////////////////////////////////////////////
	//
	//	Класс WordRuleSetsIterator. Используется для перебора правил для каждого слова. 
	//  Инициализируется в SearchWord, далее используется GetNextRuleSet.
	////////////////////////////////////////////////////////////////////////////////////
	struct WordRuleSetsIterator 
	{
		friend class WordSet_v1;

	private:
		bool first;

#ifdef _ML_PARSER_

		std::map<std::string,std::vector <MorphoInflectionRulesSet_v1 *> > ::const_iterator itr;
		std::vector <MorphoInflectionRulesSet_v1 *>::const_iterator inflruleset_iter;
#else
		const STAT_VECTOR_SIZE_V1 *ptr;
#endif
	};
	



	///////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Функция SearchWord. Поиск слова в списке слов
	//						
	//		На входе: word - слово, которое ищем
	//
	//
	//		На выходе: 
	//				значение функции - результат поиска слова (найдено/не найдено)
	//				iter - итератор, который впоследствии используется для получения правил, соответствующих слову	
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////
	bool SearchWord(const MCHAR *word, WordRuleSetsIterator &iter,
							MCHAR * partialFormBuffer = NULL, Int32 bufSize = 0,
							const MorphoInflectionRulesSet_v1 * rsArray = NULL,
							Int32 rsArrSize = 0) const;

	///////////////////////////////////////////////////////////////////////////////////////////////////
	// Автор: Павел Морозов. Октябрь 2007
	//
	// Функция EnumWords. Получение всех базовых форм всех слов морфологического модуля 
	//						с правилами по которым они изменяются
	//		На входе: 
	//
	//
	//		На выходе: 
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////
	typedef bool EnumWordsCallBackT(const MCHAR* word, WordRuleSetsIterator &iter, void* param);
	bool EnumWords(EnumWordsCallBackT* callback, void* param) const;

	///////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//	Функция GetNextRuleSet. Возвращает указатель на правило для слова, которое предварительно искалось и 
	//			было найдено с помощью SearchWord. Выполняет роль итератора для множества правил одного слова
	//
	//	На входе: итератор 
	//
	//	На выходе: измененный итератор, ссылка на правило если итератор указывает не на последний элемент, иначе NULL
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////
	const MorphoInflectionRulesSet_v1* GetNextRuleSet(WordRuleSetsIterator &iter) const;


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//	komissarov
	//	функция сравнения двух строк, полный аналог strncmp
	//	на входе: две сравниваемые строки и кол-во сравниваемых символов
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////
	Int32 StrNCMP(UInt8* szString1, UInt8* szString2, Int32 nSize) const;

	///////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//	Метод Insert. Добавляет к списку правил слова еще одно. 
	//			Если такого слова нет, добавляет слово и данное правило 
	//
	//	На входе: слово, ссылка на правило. 
	//
	//	На выходе: факт удачного завершения операции
	//
	//	Примечание: метод работает только в реализации "работа с памятью", т.е. создание, модификация и сохранение 
	//			списка слов.
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef _ML_PARSER_
	bool Insert(const MCHAR *word,  MorphoInflectionRulesSet_v1* Mo);
#endif


	///////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//	Функция Save. Сохраняет список слов с соответствующими правилами в файл.
	//	
	//	На входе: файл, в который будет сохранен класс. Указатель в файле должен быть установлен на ту позицию, 
	//			с которой начнется сохранение класса
	//
	//	Примечание: метод работает только в реализации "работа с памятью", т.е. создание, модификация и сохранение 
	//			списка слов.
	//////////////////////////////////////////////////////////////////////////////////////////
#ifdef _ML_PARSER_
	void Save(char *fileName); 
#endif



private:

	///////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//////////////////////////////////////////////////////////////////////////////////////////
	typedef struct{
		UInt8 w[4];
		Int32 bit;
	}IndexArrayElement;

#ifdef _ML_PARSER_

	typedef std::map<std::string,std::vector <MorphoInflectionRulesSet_v1 *> > MapWords;

	// карта для хранения слов
	MapWords w;

#else
	const MorphoData_v1 *MorphoPtr;

#endif

	// описание заголовка с размерами структур данных, хранимого в файле
public:

	struct Data
	{
		// количество элементов в массиве, который представляет дерево Хаффмана
		Int32						HaffmanTableSize; 

		// количество элементов в индексном массиве (массив предназначен для предварительной навигации по архиву)
		Int32						IndexTableSize; // количество элементов в индексе
		
		// размер архива слов
		//Int32						ArchiveSize;	

		// Количество блоков в архиве
		Int32						ArchiveBlockCounter;

		// массив с размерами блоков архива
		//Int32*						BlockSizeArray;
	
		
		// размер массива с "внутренними", т.е. двухбайтными ссылками
		Int32						RuleSetArraySize;
	};

	
private:

	// ссылка на буфер-дерево Хаффмана
	const UInt8		*HaffmanTable; // дерево Хаффмана
	// размер дерева Хаффмана (которое хранится в линейном массиве), в байтах
	Int32					HaffmanTableSize; 

	// ссылка массив адресов-точек входа в архив
	const IndexArrayElement	*IndexArray;
	// размер таблицы элементов индекса ( с точками входа в архив), в байтах
	Int32					IndexTableSize; 

	// размер таблицы с номерами (в байтах)
	Int32					RuleSetArraySize;
	// ссылка на буфер-массив правил.
	const STAT_VECTOR_SIZE_V1	*RuleSetArray;


	// количество блоков в архиве (количество)
	Int32					ArchiveBlockCounter; 
	// массив с размерами блоков архива
//	const Int32				*BlockSizeArray;

	// Массив указателей на блоки архива.
	#ifdef _ML_PARSER_
		pBlockType				*ArchiveBlockArray;
	#else
		const CSDCReadMy::Resource	*ArchiveBlockArray;
	#endif
	


#ifdef _ML_PARSER_
	// эти методы используются при сохранении данных в файл и вызываются из Save() 



	/////////////////////////////////////////////////////////////////////////
	//
	// Функция CreatePrefixList создает из списка слов префиксный список, 
	// в котором вместо слов хранятся лишь их отличия от непосредственного 
	// предшественника
	//
	/////////////////////////////////////////////////////////////////////////
	void				CreatePrefixList(s_word *WordList, Int32 index, Int32 maxrulenum);


	/////////////////////////////////////////////////////////////////////////
	//
	// Функция SortList. Сортирует список слов в алфавитном порядке, 
	// используя алгоритм Шелла. Алгоритмическая сложность - O(n^1.25)
	//
	//
	/////////////////////////////////////////////////////////////////////////
	void				SortList(s_word *WordList, Int32 index);
#endif

	public:
	//////////////////////////////////////////////////////////////////////////////////////////////
	//
	//	Метод Init. Производит инициализацию внутренних структур для последующего использования.
	//
	//	На входе: указатель на буфер, в котором размещены все требуемые классу данные, размер этого буфера 
	//
	//	На выходе: ---
	//
	//	Примечание: метод работает только в реализации "работа с памятью", т.е. создание, модификация и сохранение 
	//			списка слов.
	//
	//////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _ML_PARSER_
	void Init(	const UInt32 *ArchHeader,
		const CSDCReadMy::Resource *ArchivePtrArray,
		const void	*IndexArrayPtr,
		const STAT_VECTOR_SIZE_V1 *RulesSetPtr,
		const UInt8	*HuffmanTreePtr,
		const MorphoData_v1 *morphoPtr);
		
	void Close();
#endif
};

#endif
